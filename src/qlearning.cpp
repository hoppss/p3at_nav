#include <iostream>
#include <string>
#include <string.h>
#include <time.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>

#include <ros/ros.h>
#include <tf/tf.h>
#include <nav_msgs/Odometry.h>
#include <geometry_msgs/Twist.h>

#include <eigen3/Eigen/Dense>
#include <fstream>
#include <string>
#include <sstream>
#include <map>

using namespace std;
using namespace Eigen;

// I think Q matrix and R matrix must be same
// and it must be same both row and column

#define MATRIX_ROW 50
#define MATRIX_COLUMN 50
// state num must be equal to action num
#define STATE_NUM 50
#define ACTION_NUM 50
#define DES_STATE 44
#define MAX_EPISODE 200
// this value using for Q(s,a)=R(s,a)+alpha * max{Q(s', a')}
// Q(s', a') is the all next step Q value
//#define alpha 0.8

double Q[100][100];

int possible_action[50];
int possible_action_num;

int best_action;
double max_q;

double R[100][100] = 
{
{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//0    [5,9]
{ 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//1    [5,10]
{-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//2    [3,10]
{-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//3    [3,7]
{-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//4    [6,7]
{-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//5    [6,4]
{-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//6    [8,4]
{-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//7    [8,3]
{-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//8    [10,3]
{-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//9    [10,6]
{-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//10   [13,6]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//11   [13,9]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//12   [16,9]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//13   [13,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//14   [12,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//15   [12,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1, 0,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//16   [16,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//17   [15,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//18   [15,12]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//19   [13,12]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//20   [17,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//21   [17,11]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//22   [16,11]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//23   [13,15]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//24   [15,15]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//25   [15,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//26   [17,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//27   [19,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//28   [17,15]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//29   [15,16]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//30   [13,16]
//0| 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49| 
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//31   [12,16]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//32   [12,18]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//33   [12,19]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//34   [13,19]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//35   [10,18]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//36   [10,16]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//37   [10,15]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},//38   [9,16]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},//39   [9,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1,-1},//40   [6,13]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1,-1,-1,-1,-1,-1,-1},//41   [6,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1,-1,-1,-1,-1,-1, 0, 0},//42   [8,10]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 100,-1,0,-1,-1, 0},//43   [9,9]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 100,-1,-1,-1,-1,-1},//44   [12,9]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 100,-1,0,-1,-1,-1},//45   [12,7]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1, 0,-1,-1},//46   [9,7]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,-1, 0,-1},//47   [9,6]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0,-1,-1,-1,-1, 0,-1,-1},//48   [8,6]
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0,-1,-1,-1,-1,-1,-1},//49   [9,10]
};

double point[50][2]={{5,9},{5,10},{3,10},{3,7},{6,7},{6,4},{8,4},{8,3},{10,3},{10,6},{13,6},{13,9},{16,9},{13,10},{12,10},{12,13},{16,10},{15,10},{15,12},{13,12},{17,10},{17,11},{16,11},{13,15},{15,15},{15,13},{17,13},{19,13},{17,15},{15,16},{13,16},{12,16},{12,18},{12,19},{13,19},{10,18},{10,16},{10,15},{9,16},{9,13},{6,13},{6,10},{8,10},{9,9},{12,9},{12,7},{9,7},{9,6},{8,6},{9,10}};

std::map<int, std::vector<int> > possible_actions;

class action {
		int diff;
		double qvalue;
		double rvalue;

		public:
		action () {}
		action ( int i) {
				diff = i;
		}
		action ( int i, double q) {
			diff = i;
			qvalue = q;
		}
		action ( int i, double q,  double r ) {
			diff = i;
			qvalue = q;
			rvalue = r;
		}

		double get_q() {
			return qvalue;
		}

		void update_q( double alpha) {
			qvalue=rvalue+alpha;
		}

		int get_diff() {
			return diff;
		}

		void print () {
			std::cout << qvalue << "[" << diff << "]";
		}
};

class state {

	int i_max;
	double q_max;
	double point_s[2];
	std::vector<action> possibles_actions;

	public:
	state () {}
	state (int id) {
		point_s[0]=point[id][0];
		point_s[1]=point[id][1];

		for ( int i=0; i<ACTION_NUM; i++) {
			if ( R[id][i] >= 0 ) {
				action tmp(i-id, Q[id][i], R[id][i]+1);
				possibles_actions.push_back(tmp);
			}
		}

		q_max=0;
		i_max=0;

		this->best();
	}
	//typedef *state Iterator;

	void best() {
		for ( int i=0; i<possibles_actions.size(); i++) {
			double q = possibles_actions[i].get_q();
			if (q_max < q) {
				q_max = q;
				i_max = i;
			}
		}
	}

	double get_max () {
		return q_max;
	}

	int get_i_max() {
		return i_max;
	}

	int size() {
		return  possibles_actions.size();
	}

	void update_q( int idx, double alpha) {
		possibles_actions[idx].update_q(alpha);
		// update maximum q
		if ( q_max  < possibles_actions[idx].get_q() ) {
			std::cout << "Update maxQ" << std::endl;
			q_max = possibles_actions[idx].get_q();
			i_max = idx;
		}
	}

	int get_diff(int idx) {
		return possibles_actions[idx].get_diff();
	}

	void print() {
		for ( int i=0; i<possibles_actions.size(); i++) {
			possibles_actions[i].print();
			std::cout << " ";
		}
	}
};

class environment {
	std::vector<state> states;
	public:
	environment () {
		for ( int i=0; i<STATE_NUM; i++) {
			state tmp(i);
			states.push_back(tmp);
		}
	}

	int simulate (int state_idx, int action_idx) {
		return state_idx+states[state_idx].get_diff(action_idx);
	}

	int size() {
		return states.size();
	}

	// Update a random action and return next state
	int update_random( int state_idx) {
		// take a random action
		int action_idx = rand() % states[state_idx].size();
		// take next state over action
		int next_state = this->simulate(state_idx, action_idx);
		// take maxQ value on next state
		double tmp_q_max = states[next_state].get_max();
		// update Q value using alpha=0.8
		states[state_idx].update_q( action_idx, 0.8*tmp_q_max);
		return next_state;
	}

	// 
	int best_action( int state_idx ) {
		int action_idx = states[state_idx].get_i_max();
		return this->simulate(state_idx, action_idx);
	}

	void print () {
		for ( int i=0; i<states.size(); i++) {
			std::cout << "State[" << i << "] ";
			states[i].print();
			std::cout << std::endl;
		}
	}
};


class qlearning {
	environment E;

	public:
	qlearning () {}

	void episode_iterator (int *init_state, int target ) {
		// start series event loop
		while (1) {
			// Toma uma ação aleatória
			*init_state = E.update_random(*init_state);
			if ( *init_state == target ) {
				*init_state = rand() % E.size();
				break;
			}
			std::cout << "[" << *init_state << "]";
		}
		std::cout << std::endl;
	}

	void run_training(int init, int target, int max_episodes) {
		int init_state=init;
		//start random
		srand((unsigned)time(NULL));
		for (int i = 0; i < max_episodes; ++i) {
			cout << "[INFO] Episode: " << i << " " << init_state << endl;
			this->episode_iterator( &init_state, target);
			cout << "-- updated Q matrix: " << endl;
		}
	}

	void exec ( int position, int target, int max_episodes ) {
		this->run_training ( position, target, max_episodes);
		// Exec experiment
		int idx=0, sequence[max_episodes];
		sequence[idx]=position;
		while( idx <= max_episodes ) {
			position = E.best_action(sequence[idx]);
			idx++;
			sequence[idx] = position;
			cout << sequence[idx] << "->";
			if ( sequence[idx] == target ) {
				cout << "Estado Final<-" << endl;
				break;
			}
		}
		// Executa a rota encontrada
		for(int j=0; j<idx; j++) {
			cout << "Próximo ->" << sequence[j+1] 
				<< " - X:" << point[sequence[j+1]][0] 
				<< " Y:" << point[sequence[j+1]][1] << endl;
		}
		E.print();
	}

};

//----------------------------------------------------------------------------
ros::Publisher r0_cmd_vel_pub;

ros::Subscriber r0_pose_sub;

geometry_msgs::Twist cmd_vel_msg;

double r0X, r0Y;
double r0uX;
double r0uY;

double r0dX=0;

double r0dY=0;

void r0_pose (const nav_msgs::Odometry::ConstPtr& msg)
{
	r0X=msg->pose.pose.position.x;
	r0Y=msg->pose.pose.position.y;
}

int main(int argc, char** argv) {

	ros::init(argc, argv, "QLearning");
	ros::NodeHandle nh;

//	r0_cmd_vel_pub = nh.advertise<geometry_msgs::Twist>("/robot_0/cmd_vel", 10);

//	r0_pose_sub = nh.subscribe("/robot_0/base_pose_ground_truth", 10, r0_pose);

	//create_possible_actions();

	//run_training(1);

	qlearning teste;

	int position;

	cout << "Insira o inicial [0 - 49]: " << endl;
	cin >> position;
	cout << position << "->";

	teste.exec(position, DES_STATE, 50);
/*
	// Executa o experimento até chegar no destino para garantir o
	// funcionamento?
	int i=0, sequence[50];
	sequence[i]=position;
	while(1) {
		i++;
		update_max(position);
		cout << best_action << "->";
		if (best_action == DES_STATE) {
			cout << "Estado Final<-" << endl;
			sequence[i]=best_action;
			break;
		} else {
			position = best_action;
			sequence[i]=position;
		}
	}

	// Executa a rota encontrada
	for(int j=0; j<i; j++) {

		cout << "Próximo ->" << sequence[j+1] 
				<< " - X:" << point[sequence[j+1]][0] 
				<< " Y:" << point[sequence[j+1]][1] << endl;

		r0uX=0;
		r0uY=0;

		// Simula a ação de controle
//		do {
//			ros::spinOnce();
//			r0uX = (point[sequence[j+1]][0]-r0X);
//			r0uY = (point[sequence[j+1]][1]-r0Y);
//			if(j!=i) {
//				cmd_vel_msg.linear.x=vx;
//				cmd_vel_msg.linear.y=vy;
//				r0_cmd_vel_pub.publish(cmd_vel_msg);
//			}
//		} while ( fabs(r0uX)+fabs(r0uY)>0.2 );

	}
*/
	return 0;
}
